<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><title>Refactoring</title>
	<link rel="StyleSheet" href="./ide.css" type="text/css">
</head>
<body>
<h1>Refactoring</h1>
<p><font color="teal"> "The digital age has its own uncertainty principle: 
Issues get fuzzier as their parts get more precise."</font> <i> 
Professor Bart Kosko in Heaven in a Chip </i></p>
<br>
<p><b>
Designing optimal code at the very start of a project is an 
enormous, if not impossible task.</b>
<br>
As software projects evolve, it is often necessary to re-evaluate architecture and/or implementation decisions for a variety of reasons such as:
<table align="center" width="100%"> <tr> <td align="center" width="50%">
<ul> <li> <p>
New requirements are added.
</p></li><li><p>
Overlooked issues are discovered.
</p></li><li><p>
Functional demands are clarified.
</p></li><li><p>
Business requirements are altered.
</p></li><li><p>
Legacy systems are reused.
</p></li></ul></td><td align="center"  width="50%">
<ul> <li><p>
Customer goals are redefined.
</p></li><li><p>
Improved methods are utilised.
</p></li><li><p>
Hardware/Software platforms change.
</p></li><li><p>
Key personnel are reassigned.
</p></li><li><p>
Outside code bases are imported.
</p></li></ul>
</td></tr></table>
</p>

<p>Thus causing changes in the design and format of the resulting code.   Additionally, even well designed code suffers when developers make quick fix `workarounds' to meet deadlines, patch coding holes, underlying technologies change, or functionality is added beyond the scope of the original design. As this is a natural course of events, if appropriate measures are not taken to fight "software rot" - costs rise and productivity decreases.  The end result is that developed code is wasted as organizations often find it easier to `reinvent the wheel' by writing code from scratch rather than invest the time and effort into maintaining existing systems.</p>
<br>
<p>This inefficient use of informatic capital and problematic recycling does not have to occur. With <i>refactoring</i>, complexity is continually managed and the need for change is addressed early on, hence robust projects can be effectively developed and legacy systems maintained at a fraction of their replacement costs.  It is easier to fix a dam than it is to replace it.  <i>Refactoring</i> proactively ensures that code is more understandable as well as efficiently constructed by selectively moving algorithms, removing duplicate code, and clarifying `big picture' issues as they occur. Thus, refactoring actively fights `software rot' by improving design, readability, and maintainability of code in general, while increasing the productivity of programmers.</p>

<h3>Refactoring and Quality</h3>
<p>The key to good <i>refactoring</i> is to continuously perform small enhancements with occasional overall reviews as a natural programming activity vice end of cycle chore.  The crux of refactoring is that changes to code do not change functionality - changes only decrease complexity and redundancy.  When code is clean, efficient, and understandable - it requires less resources, effort, and bug tracking to enhance and maintain. The increase in productivity is both remarkable and quantifiable as developers on a project can utilize time understanding and manipulating code, resulting in increased quality via reuse of `tested' code.</p>

</body></html>
